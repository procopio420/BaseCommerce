# Multi-Tenancy Routing

## Strategy

**Subdomain-based multi-tenancy** with data isolated by `tenant_id` in all tables.

## Centralized Architecture

The Auth Service owns the Tenant, User, and TenantBranding models. Verticals (e.g., Construction) do not have these models - they only use JWT claims.

```
┌─────────────────────────────────────────────────────────────────┐
│                         Auth Service                             │
│                                                                  │
│  Models:                      Endpoints:                        │
│  - Tenant                      - /auth/login                     │
│  - User                        - /tenant.json                    │
│  - TenantBranding              - /auth/me                        │
└─────────────────────────────────────────────────────────────────┘
                                 │
                                 │ JWT with claims:
                                 │ - sub (user_id)
                                 │ - tenant_id
                                 │ - email
                                 │ - role
                                 ▼
┌─────────────────────────────────────────────────────────────────┐
│                         Vertical                                 │
│                                                                  │
│  Extracts UserClaims from JWT (no database query)               │
│  All queries use tenant_id from JWT                              │
└─────────────────────────────────────────────────────────────────┘
```

## Resolution Flow

```
1. User accesses: lojadoze.basecommerce.com.br
                              │
                              ▼
2. Nginx extracts subdomain: lojadoze
                              │
                              ▼
3. Nginx injects header: X-Tenant-Slug: lojadoze
                              │
                              ▼
4. If not authenticated, redirects to /auth/login
                              │
                              ▼
5. Auth Service looks up tenant in database by slug
                              │
                              ▼
6. Auth Service creates JWT with tenant_id in claims
                              │
                              ▼
7. Vertical extracts tenant_id from JWT
                              │
                              ▼
8. All queries filter by tenant_id
```

## Nginx Configuration

```nginx
# Extract tenant from subdomain
map $host $tenant_slug {
    ~^(?<subdomain>[^.]+)\.basecommerce\.com\.br$ $subdomain;
    ~^(?<subdomain>[^.]+)\.localhost$ $subdomain;
    default "";
}

server {
    listen 80;
    server_name *.basecommerce.com.br *.localhost localhost;
    
    # Tenant JSON served by Auth Service
    location = /tenant.json {
        proxy_pass http://auth_service/tenant.json;
        proxy_set_header X-Tenant-Slug $tenant_slug;
    }
    
    # Login redirects to Auth Service
    location = /web/login {
        return 302 /auth/login;
    }
    
    # Auth endpoints
    location /auth/ {
        proxy_pass http://auth_service/;
        proxy_set_header X-Tenant-Slug $tenant_slug;
    }
    
    # Vertical
    location / {
        proxy_pass http://construction:8000;
        proxy_set_header X-Tenant-Slug $tenant_slug;
    }
}
```

## JWT Claims

The JWT generated by Auth Service contains:

```json
{
  "sub": "user-uuid",
  "tenant_id": "tenant-uuid",
  "email": "user@example.com",
  "role": "admin",
  "exp": 1234567890
}
```

## UserClaims in Vertical

The vertical extracts claims from JWT without querying the database:

```python
@dataclass
class UserClaims:
    id: UUID
    tenant_id: UUID
    email: str
    role: str


async def get_current_user(credentials: HTTPAuthorizationCredentials) -> UserClaims:
    token = credentials.credentials
    payload = decode_access_token(token)
    
    return UserClaims(
        id=UUID(payload["sub"]),
        tenant_id=UUID(payload["tenant_id"]),
        email=payload["email"],
        role=payload["role"],
    )
```

## Tenant Branding

Branding is served dynamically by Auth Service via `/tenant.json`:

```json
{
  "slug": "lojadoze",
  "name": "Loja do Zé",
  "logo_url": "https://...",
  "primary_color": "#1a73e8",
  "secondary_color": "#ea4335",
  "features": {
    "cotacoes": true,
    "pedidos": true
  }
}
```

Configuration is stored in the database:

```sql
CREATE TABLE tenant_branding (
    tenant_id UUID PRIMARY KEY REFERENCES tenants(id),
    logo_url VARCHAR(500),
    primary_color VARCHAR(7) DEFAULT '#1a73e8',
    secondary_color VARCHAR(7) DEFAULT '#ea4335',
    feature_flags JSONB DEFAULT '{}'
);
```

## Local Development

### Without Subdomain

Access directly `http://localhost:8000/web/dashboard`. The system works without a specific tenant (development mode).

### With Subdomain

1. Add to `/etc/hosts`:
```
127.0.0.1 demo.localhost
```

2. Start services:
```bash
cd infra/envs/development/local
docker compose up -d
```

3. Access: `http://demo.localhost/auth/login`

The middleware resolves `demo` as slug via X-Tenant-Slug header.

## Data Isolation

**ALL** business data queries filter by `tenant_id`:

```python
cotacoes = (
    db.query(Cotacao)
    .filter(Cotacao.tenant_id == user.tenant_id)  # From JWT claims
    .order_by(Cotacao.created_at.desc())
    .all()
)
```

**Engines** also respect `tenant_id` in events:

```python
envelope = EventEnvelope(
    event_id=uuid4(),
    event_type="sale_recorded",
    tenant_id=tenant_id,  # Always present
    payload={...}
)
```

## Creating a New Tenant

Tenant creation is done directly in the database (or future admin panel in Auth Service):

```python
from auth_app.models import Tenant, TenantBranding, User
from basecore.security import get_password_hash

# 1. Create tenant
tenant = Tenant(
    nome="Nova Loja",
    slug="novaloja",  # Subdomain
    cnpj="12.345.678/0001-90",
    email="contato@novaloja.com",
    ativo=True
)
db.add(tenant)
db.commit()

# 2. Create branding (optional)
branding = TenantBranding(
    tenant_id=tenant.id,
    primary_color="#1a73e8"
)
db.add(branding)
db.commit()

# 3. Create admin user
user = User(
    tenant_id=tenant.id,
    nome="Admin",
    email="admin@novaloja.com",
    password_hash=get_password_hash("senha123"),
    role="admin",
    ativo=True
)
db.add(user)
db.commit()
```

After this, the tenant can access via `novaloja.basecommerce.com.br`.
